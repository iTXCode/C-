### 第一章

**数据:** 描述事物的符号记录

**数据库:** 长期存储在计算机内、有组织的、可共享的大量数据的集合

**数据库管理系统:** 位于用户和操作系统之间的一层数据管理软件，用于科学地组织和存储数据，高效地获取和维护数据

**数据库系统:** 由数据库、数据库管理系统(及其应用开发工具)，应用程序和数据库管理员组成的储存、管理、处理和维护数据的系统

**实体:** 客观存在并可以相互区别的事物

**属性：** 实体所具有的某一特性

**码：** 唯一标识实体的属性集

**联系：** 实体之间的联系通常指不同实体集之间的联系(实体之间的联系:一对一，一对多，多对多几种)



#### 数据库特点:1.数据结构化2.数据的共享性高，冗余度低且易扩充3.数据独立性高4.数据由数据库管理系统统一管理和控制

#### 数据模型：是数据库中用来对现实世界进行抽象的工具，是数据库中用于提供信息表示和操作手段的形式构架

**逻辑数据模型**

**三要素：**  1.数据结构 2.数据操作3.数据的完整性约束条件

#### 数据库系统结构

#### 三级模式的优点

##### 使用户能够逻辑的、抽象的处理数据、而不必关系数据在计算机中的具体表示方式与存储方式

##### 1.模式:是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图

##### 2.外模式:也成子模式或用户模式。外模式通常是模式的子集

##### 3.内模式： 一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式(数据库的内模式依赖于它的全局逻辑结构)

##### 二级映像:

###### 1.外模式/模式映像:定义了该外模式与模式之间的对应关系，

###### 逻辑独立性:。应用程序是依据数据的外模式编写的，从而应用程序不必修改。保证了数据与程序的逻辑独立性

###### 2.模式/内模式映像:定义了数据全局逻辑结构和存储结构之间的对应关系，

###### 物理独立性: 数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。

### 第二章

#### 关系模式

##### 关系：关系模式中数据逻辑的一张表就叫关系 

**(关系是关系模式在某一时刻的状态或内容)，关系模式是静态的稳定的，而关系是动态的**

##### 元组：笛卡儿积中的 一个元素 叫做一个元组

##### 属性：二维表中的一列叫做属性

##### 关系模式:对关系的描述，

##### 候选码：若关系的某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为候选码

##### 外码：如果关系中属性或者属性组不是本关系的码，而是引用其他关系或者本关系的码；则称该关系的外码

##### 主码：当有多个候选码的时候，选择其中的一个作为主码

##### 主属性：候选码的诸属性

##### 非主属性：不包含在任何候选码中的属性

##### 关系的性质：一个关系中不能有两个完全相同的元组，元组顺序无所谓；不能有两同名属性；属性可取自同一个域

#### 数据操作

#### 实体完整性

##### 实体完整性规则：若属性(指一个或者属性)A是基本关系R的主属性，则A不能取空值(null value)

**主码非空且唯一**

#### 参照完整性

##### 参照完整性规则：若属性(或属性组)F是基本关系R的外码，它的基本关系S的主码Ks相对应。

##### 外码不能引用不存在的值

##### 用户定义的完整性约束：和具体的业务规则相关

###        数据操作

#### 关系代数

##### 除运算:设关系R除以关系S的结果为关系T，则T包含所有在R单不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中

#### 数据更新

##### 插入元素:insert

````
insert
into student(sno,sname,ssex,sdept,sage)
values('20121526','张三','男’,'is');
````

##### 修改数据:update

````
update student
set sage=22
where sno='201215121';
````

##### 删除数据delete

````
delete
from student
where sno='20121518'
````

#### 视图

##### 定义视图

````
//建立信息系学生系统视图
create view IS_student
as
select sno,sname,sage
from student
where sdept='is';
````

##### 删除视图

````
drop view BT_IS
````

##### 查询视图

````
select sno,sage
from is_student
where sage<20;
````

##### 更新视图

````
update IS_Student
set Sname='刘晨'
where sno='201215122'and sdept='is'
````



### 第四章

##### DAC(自动存取控制)

> 在TCSEC中属于C2级别；
>
> c1级别只提供非常初级的自主安全保护，能够实现对用户何数据的分离。



##### MAC(强制存取控制)

> 在TCSEC中属于B1级别



##### 授权用户(GRANT)

````
//把查询student表的权限授给用户
grant select
on table student
to u1
````

````
//把对student表和表course表的全部操作权限授予用户u2和u3
grant all privileges
on table student,course
to u1,u2
````

````
//把对表sc的查询权限授予所有用户
grant select
from table sc
to public;
````

````
//把对表sc的insert权限授予U5用户，并允许将此权限再授予其他用户
grant insert
on table sc
to u5
with grant option
````

##### 收回权限(REVOKE)

````
//把用户u4修改学生学号的权限收回
revoke update(sno)
on table student
from u4;
````

````
//收回所有用户对表scc的查询权限
revoke select 
on table sc
from public;
````

````
//把用户u5对sc表的insert权限收回
revkoe insert
on table sc
from u5 cascade
````

### admin将角色授予其它角色或者用户

### grant 将权力授予其他用户



#### 角色:数据库角色是被命名的一组数据库操作相关的权限，角色是权限的集合

##### 角色的创建

````
grant role <角色名>
````

##### 给角色授权

````
grant <权限>
on <对象>
to<角色>
````

##### 将一个角色授予其他的角色或用户

````
grant <角色>
to <角色>
[with admin option]
````

##### 角色权限收回

````
revoke<权限>
on <对象类型><对象名>
from <角色>
````

##### 通过角色来实现将一组权限授予一个用户

##### 首先创建一个角色R1

````
create role R1;
````

##### 使用grant语句，使角色R1拥有student表的SELECT，UPDATE，INSERT权限

````
　grant　selet，UPDATE，INSERT
　ON TABLE 　STUDENT
　TO　Ｒ１；
````

##### 将这个角色授予王平、张明、赵玲，是他们具有角色Ｒ１所包含的全部权限

````
GRANT R1
TO 王平，张明，赵玲；
````

##### 一次性地通过R1来收取王平的这三个权限

````
REVOKE R1
FROM 王平；
````

### 第五章

#### 数据库的完整性

##### 数据库的完整性是指数据的正确性和相容性

##### 定义完整约束(primary key)

##### 定义参照完整性约束(foreign key(对象) references 表名(参照对象))

**参照完整性约束将两个表中相应元组联系起来了**



4 . DBMS  的完整性控制机制应具有哪些功能？

答 :

DBMS  的完整性控制机制应具有三个方面的功能：  ( l  ）定义功能，即提供定义完整性约束条件的机制；  ( 2  ）检查功能，即检查用户发出的操作请求是否违背了完整性约束条件； ( 3  ）违约反应：如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。



 5 . RDBMS  在实现参照完整性时需要考虑哪些方面？

答  

RDBMs  在实现参照完整性时需要考虑以下几个方面：  

( l  ）外码是否可以接受空值。

( 2  ）册  l  除被参照关系的元组时的考虑，这时系统可能采取的作法有三种：  l  ）级联删除（  CASCADES ) ; 2  ）受限删除（  RESTRICTED ) ; 3  ）置空值删除（  NULLIFIES  ）。  ( 3  ）在参照关系中插入元组时的问题，这时系统可能采取的作法有：  l  ）受限插入；  2  ）递归插入。  

( 4  ）修改关系中主码的问题。一般是不能用  UPDATE  语句修改关系主码的。如果需要修改主码值，只能先删除该元组，然后再把具有新主码值的元组插入到关系中。如果允许修改主码，首先要保证主码的惟一性和非空，否则拒绝修改。然后要区分是参照关系还是被参照关系。

#### 完整性约束命名子句

##### 1.完整性约束命名子句

**constraint<完整性约束条件名> <完整性约束条件>**

**其中完整性(NOT　ＮULL,UNIQUE,PRIMARY KEY,FOREIGN KEY,CHECK)**

**建立学生登记表Student,要求学号在90000~999999之间，姓名不能取空值，年龄小于30,性别之能是"男"或"女"**

````
create table student
(
sno numeric(10)
constraint c1 check(sno berween 90000 and 999999),
sname char(20)
constraint c2 not NULL,
sage numeric(3)
constraint c3 check(sage<30),
ssex char(2)
constraint c4 check(ssex in('男','女')),
constraint studentKey primary key(sno)
)
````

##### 删除对性别的限制

````
alter table student
drop constraint c4;
````





#### SQL还在CREATETABLE语句中提供了完整性约束命名子句CONSTRAINT，用来完整性约束条件命名，从而可以灵活的增加，删除一个完整性约束条件。





### 第六章

#### 关系模式

**R(U,D,DOM,F)  一个关系模式应当是一个五元组**

> 其中关系名R是符号化的元组语义
>
> U为一组属性
>
> D为属性组U中的属性所来自的域
>
> DOM为属性组到域的映射
>
> F为属性组U上的一组数据依赖

#### 函数依赖

##### 非平凡函数依赖:X->Y,但Y不包含于X，则称X-> Y是非平凡的函数依赖

##### 平凡的函数依赖: X->Y，但Y包含于X,则称X->Y是平凡的函数依赖

##### 决定因素：若X—>Y，则X称为这个函数依赖的决定属性组，也称为决定因素

#### 范式

##### 规范化：一个低级范式的关系模式通过模式分解可以转化为若干个高一级凡是的关系模式的集合，这个 过程叫做规范化

### 第七章：数据库设计

##### 数据库设计：指对于一个给定的应用环境，构造（设计） 优化的 数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求

##### 数据库设计特点之一：三分技术，七分管理，十二分基础数据

##### 数据库设计方法

**1.计算机基础知识**

**2.软件工程的原理和方法**

**3.程序设计的方法和技巧 **

**4.数据库的基本知识**

**5.数据库设计技术**

**6.应用领域知识**

##### 数据库设计基本步骤

**1.需求分析**

**2.概念机构设计**

**3.逻辑结构设计**

**4.物理结构设计**

**5.数据库实施**

**6.数据库运行和维护**

#### ER图

##### 实体用矩形表示

##### 属性用椭圆表示

##### 联系用菱形表示

### 第十章：数据库恢复技术

##### 事务:用户定义的一个数据库操作序列，这些操作要么全做，要么不做，是一个不可分割的工作单位

##### 在SQL中定义事务的语句一般有三条

**BEGIN TRANSACTION**（通常事务以其开始）

**COMMIT**　（表示提交即为提交了所有的操纵）

**ROLLBACK**　（表示回滚，，事务在运行过程中出现了故障）

##### 事务的ACID特性

**1.原子性**

**2.一致性**

**3.隔离性**

**4.持续性**

#### 故障的种类

##### 1.事务内部的故障

##### 2.系统故障

##### 3.介质故障(系统故障通常称为软故障 ，介质故障称为硬故障)

##### 4.计算机病毒

#### 登记日志文件

##### 日志文件:用来记录事务对数据库的更新操作的文件

##### 每个日志记录的内容主要包含

**1.事务标识**

**2.操作的类型**

**3.操作的对象**

**4.更新前数据的旧值**

**5.更新后数据的新值**



##### 事务撤销(UNDO):恢复程序要在不影响其他事务运行的情况下，强制回滚该事务，既撤销事物已经做出的任何对数据库的修改 ，使得事务好像根本没有启动一样

##### 重做(redo)：系统重启后，恢复子系统除需要撤销所有未完成的事务外，还需要重做

#### 恢复的实现技术

##### 数据转储

**当数据库遭到破环后可以将后备副本重新装入 ，但只重装后备副本只能将数据库恢复到转转储时的状态要想恢复到故障发生时的状态，必须重新运行自转以后的所有更新事务**

##### 登记日志文件要遵守的两条规则

**1.等级次序严格按照并发事务执行的时间次序**

**2.必须先写日志文件，后写数据库**

#### 恢复策略

##### 1.事务故障的恢复

**1.反向扫描日志文件，查找该事务的更新操作**

**2.对该事务的更新操作执行逆操作，既将日志记录中“更新前的 值”写入数据库**

**3.继续反复扫描 日志文件，查找该事务的 其他更新操作，并作同样的处理**

**4.如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了**

#### 系统故障的恢复

**1.正向扫描日志文件，找到在事故发生前已经提交的事务，将其事务标识记入重做队列(这些事务只有BEGINTRANSACTION记录，没有相应的COMMIT记录)，将其事务标识记入撤销队列 （UNDO-LIST）**

**2.对撤销队列中的各个事务进行撤销(UNDO)处理**

**3.对重做队列中的是事务进行重做处理**

#### 介质故障恢复

**1.装入最新的数据库后备副本，使数据恢复到最近一次转储时的一致性状态**

**2.装入相应的日志文件副本重做已完成的事务**

##### 具有检查点的恢复策略效率更高原因

**1.扫描日志文件是从检查点开始，无需扫描整个日志文件**

**2.检查点设立之前已完成的事务无需重做**

### 第十一章

#### 11.1并发控制概述

##### 丢失修改:两个事务T1和T2读入统一数据并修改，T2提交的 结果破坏了T1提交 的结果，导致T1 修改被丢失（写时写冲突）

##### 不可重复读：事务T1 读取数据后，事务T2 执行更新操作，时T1 无法再现前一次 读取结果。

##### 读“脏”数据：事务T1修改过的 数据恢复原值，T2读取同一数据后，T1 由于某种原因被撤销，这时被T1修改过的数据恢复原值，T2数据于数据库中的数据不一致，则称T2读到的数据就为“脏数据”。

#### 11.2.封锁

##### 排他锁也称写锁

##### 共享锁又称读锁

#### 11.3封锁协议

##### 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放锁

##### 二级封锁协议：在一级封锁协议基础上增加事务Ｔ在读取数据R之前必须先对其加S锁，读完后即可释放S锁

##### 三级封锁协议：在一级封锁协议的基础上添加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放



### 活锁：事务T2有可能永远等待，这就是活锁。

### 避免活锁的办法：采用先来先服务的态度

### 死锁：T1在等待T2，而T2又在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁

### 死锁的预防方式：

### 1.一次封锁:要求每个事务必须将要使用的数据全部加锁，否则不能继续执行

### 2.顺序封锁法：预先对数据对象规定一个封锁顺序，所有的事务都按这个顺序实施封锁。



#### 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果和按某一次序串行执行这些事务时的结果相同，称这种调度策略是可串行化调度

#### 可串行化是并发事务正确调度的准则

### 两段锁协议：所有事务必须分两个阶段对数据项加锁和解锁